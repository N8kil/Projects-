---
title: 'Challenge 2: predicting usersâ€™ film ratings'
author: 
output: html_document
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
```

#observation <- read.csv("Kittiwake_Observation_20590303.csv",header = TRUE) 
#"C:\Users\nikhi\Desktop\MSc DS\2-Statistical Machine learning\sem 2\project\ratings_train.csv"

# The data
Load the data 
```{r}

getwd()
setwd("C:\\Users\\nikhi\\Desktop\\MSc DS\\2-Statistical Machine learning\\sem 2\\project")

ratings.train <-read.csv("C:\\Users\\nikhi\\Desktop\\MSc DS\\2-Statistical Machine learning\\sem 2\\project\\ratings_train.csv", header=TRUE)
ratings.test  <-read.csv("C:\\Users\\nikhi\\Desktop\\MSc DS\\2-Statistical Machine learning\\sem 2\\project\\ratings_test.csv", header=TRUE)
movies        <-read.csv('C:\\Users\\nikhi\\Desktop\\MSc DS\\2-Statistical Machine learning\\sem 2\\project\\movies.csv',header = T)


```

```{r}
head(ratings.train)
```

```{r}
head(movies)
```

Rating distributions
```{r}
library(dplyr)
library(ggplot2)
ratings.train %>% 
  ggplot(aes(rating)) +
  geom_histogram(binwidth = 0.25, color = "blue",fill='blue') +
  ggtitle("Rating distribution")+theme_bw()
```

The total of unique movies and users in the train set 
```{r}
ratings.train %>%
summarize(n_users = n_distinct(userId), 
          n_movies = n_distinct(movieId))
```
Number of ratings per movie
```{r}
ratings.train %>%
count(movieId) %>%
ggplot(aes(n)) +
geom_histogram(bins = 30, color = "blue",fill='blue') +
scale_x_log10() +
xlab("MovieId") +
  ylab("Number of ratings") +
ggtitle("Number of ratings per movie")+theme_bw()
```

Number of ratings per User
```{r}
ratings.train %>%
count(userId) %>%
ggplot(aes(n)) +
geom_histogram(bins = 30, color = "blue",fill='blue') +
scale_x_log10() +
xlab("UserId") +
  ylab("Number of ratings") +
ggtitle("Number of ratings per User")+theme_bw()
```


```{r}
user.ids <- sort(unique(ratings.train$userId))
movie.ids <- sort(unique(ratings.train$movieId))


library(reshape2)
X <- acast(ratings.train, userId ~ movieId, value.var="rating")

```

Let's construct some features from the timestamp variable

```{r}
ratings.train$timestamp <- as.POSIXct(ratings.train$timestamp)

# Extract day of the week
ratings.train$day_of_week <- weekdays(ratings.train$timestamp)

# You could also create a binary feature for weekend vs. weekday
ratings.train$is_weekend <- ifelse(weekdays(ratings.train$timestamp) %in% c("Saturday", "Sunday"), 1, 0)

# Extract part of the day
ratings.train$part_of_day <- cut(as.integer(format(ratings.train$timestamp, "%H")),
                           breaks=c(-Inf,6,12,18,Inf),
                           labels=c("Night", "Morning", "Afternoon", "Evening"),
                           right=FALSE)
# Extract Year
ratings.train$year <- format(ratings.train$timestamp, "%Y")

# Define a function to determine the season based on the month
getSeason <- function(month) {
  ifelse(month %in% c(3, 4, 5), 'Spring',
         ifelse(month %in% c(6, 7, 8), 'Summer',
                ifelse(month %in% c(9, 10, 11), 'Fall', 'Winter')))
}

# Extract Month as a numeric value
ratings.train$month <- as.numeric(format(ratings.train$timestamp, "%m"))

# Apply the function to determine the season
ratings.train$season <- sapply(ratings.train$month, getSeason)
```

Let's merge with the movie data for additional insights

```{r}
ratings.train<-ratings.train %>% left_join(movies,'movieId')
```

```{r}

# Split each genre string into individual genres
split_genres <- strsplit(as.character(ratings.train$genres), split = "\\|")

# Unlist and find unique genres across all movies
unique_genres <- unique(unlist(split_genres))

# Initialize a matrix to hold binary variables for genres, with the same number of rows as the 'ratings.train' dataset
genre_matrix <- matrix(0, nrow = nrow(ratings.train), ncol = length(unique_genres))

# Name the columns after the unique genres
colnames(genre_matrix) <- unique_genres

# Fill the matrix: set to 1 where the movie belongs to the genre
for (i in 1:nrow(ratings.train)) {
  genres <- strsplit(as.character(ratings.train$genres[i]), split = "\\|")[[1]]
  genre_matrix[i, genres] <- 1
}

# Convert the matrix to a data frame 
genre_df <- as.data.frame(genre_matrix)
# Bind the genre binary variables with the original dataset
ratings.train.expanded <- cbind(ratings.train, genre_df)

```

Let's train a decision tree model

```{r}
library(rpart)
library(caret)
library(rpart.plot)
library(janitor)
ratings.train.expanded<-clean_names(ratings.train.expanded)

# Define the predictor variables and the target variable
predictors <- c("part_of_day", "is_weekend", "year", "season", "action", "drama", "thriller",
                "comedy", "adventure", "sci_fi", "imax", "fantasy", "romance", "horror",
                "children", "war", "animation", "mystery", "crime", "documentary", "western",
                "musical", "film_noir", "no_genres_listed")

# Convert factor variables
ratings.train.expanded$part_of_day <- as.factor(ratings.train.expanded$part_of_day)

ratings.train.expanded$season <- as.factor(ratings.train.expanded$season)
ratings.train.expanded$year <- as.factor(ratings.train.expanded$year)   
# Split data into training (80%) and testing (20%) sets
set.seed(123) # For reproducibility
indices <- createDataPartition(ratings.train.expanded$rating, p = 0.8, list = FALSE)
trainingData <- ratings.train.expanded[indices, ]
testingData <- ratings.train.expanded[-indices, ]

# Create the formula
formula <- as.formula(paste("rating ~", paste(predictors, collapse = " + ")))

## Set up training control with additional tuning for 'cp'
train_control <- trainControl(method = "cv", number = 10, search = "grid")

# Define a grid of 'cp' values to explore
cp_grid <- expand.grid(cp = seq(0.001, 0.05, by = 0.0002))

# Train the model with complexity parameter tuning
model <- train(formula, data = trainingData, method = "rpart",
               trControl = train_control, tuneGrid = cp_grid,metric='MSE')

# Output the best model summary
print(model)



# Plot the optimized decision tree
rpart.plot(model$finalModel, type = 4,extra = 1,cex = 0.5)
#print the tree rules
rpart.rules(model$finalModel)
# Make predictions on the test set
predictions <- predict(model, newdata = testingData)

# Calculate MSE
test_rmse <- mean((predictions - testingData$rating)^2)
print(paste("Test MSE:", test_rmse))

```

Now we prepare the ratings.test data

```{r}
ratings.test$timestamp <- as.POSIXct(ratings.test$timestamp)

# Extract day of the week
ratings.test$day_of_week <- weekdays(ratings.test$timestamp)

# You could also create a binary feature for weekend vs. weekday
ratings.test$is_weekend <- ifelse(weekdays(ratings.test$timestamp) %in% c("Saturday", "Sunday"), 1, 0)

# Extract part of the day
ratings.test$part_of_day <- cut(as.integer(format(ratings.test$timestamp, "%H")),
                           breaks=c(-Inf,6,12,18,Inf),
                           labels=c("Night", "Morning", "Afternoon", "Evening"),
                           right=FALSE)
# Extract Year
ratings.test$year <- format(ratings.test$timestamp, "%Y")

# Define a function to determine the season based on the month
getSeason <- function(month) {
  ifelse(month %in% c(3, 4, 5), 'Spring',
         ifelse(month %in% c(6, 7, 8), 'Summer',
                ifelse(month %in% c(9, 10, 11), 'Fall', 'Winter')))
}

# Extract Month as a numeric value
ratings.test$month <- as.numeric(format(ratings.test$timestamp, "%m"))

# Apply the function to determine the season
ratings.test$season <- sapply(ratings.test$month, getSeason)
#merge with the movies data to get the genres
ratings.test <- ratings.test %>% left_join(movies,'movieId')

# Split each genre string into individual genres
split_genres <- strsplit(as.character(ratings.test$genres), split = "\\|")

# Unlist and find unique genres across all movies
unique_genres <- unique(unlist(split_genres))

# Initialize a matrix to hold binary variables for genres, with the same number of rows as the 'ratings.test' dataset
genre_matrix <- matrix(0, nrow = nrow(ratings.test), ncol = length(unique_genres))

# Name the columns after the unique genres
colnames(genre_matrix) <- unique_genres

# Fill the matrix: set to 1 where the movie belongs to the genre
for (i in 1:nrow(ratings.test)) {
  genres <- strsplit(as.character(ratings.test$genres[i]), split = "\\|")[[1]]
  genre_matrix[i, genres] <- 1
}

# Convert the matrix to a data frame 
genre_df <- as.data.frame(genre_matrix)
# Bind the genre binary variables with the original dataset
ratings.test.expanded <- cbind(ratings.test, genre_df)


# Convert factor variables
ratings.test.expanded$part_of_day <- factor(ratings.test.expanded$part_of_day,levels=levels(ratings.train.expanded$part_of_day))

ratings.test.expanded$season <- factor(ratings.test.expanded$season,levels=levels(ratings.train.expanded$season))
ratings.test.expanded$year <- factor(ratings.test.expanded$year,levels = levels(ratings.train.expanded$year))
ratings.test.expanded<-clean_names(ratings.test.expanded)
# Make predictions on the test set
predictions <- predict(model, newdata = ratings.test.expanded)

# Adjust the predictions to the nearest 0.5
adjusted_predictions <- round(predictions * 2) / 2
```

```{r}
write.csv(predictions, file = "film_rating_predictions_group_X_week_Y.csv", row.names=FALSE)
```

